name: Manual Deploy to Client

on:
  workflow_dispatch:
    inputs:
      client:
        description: 'Client to deploy to'
        required: true
        type: choice
        options:
          - default
          - hitotoiro

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    env:
      # ここで共通の env（必要なら）を定義
      NODE_OPTIONS: "--max_old_space_size=4096"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: Resolve client secrets into env (explicit mapping)
        id: resolve_secrets
        run: |
          CLIENT="${{ github.event.inputs.client }}"
          echo "Selected client: $CLIENT"

          if [ "$CLIENT" = "hitotoiro" ]; then
            FIREBASE_CONFIG='${{ secrets.FIREBASE_CONFIG_HITOTOIRO }}'
            GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY_HITOTOIRO }}'
            FIREBASE_SA='${{ secrets.FIREBASE_SERVICE_ACCOUNT_HITOTOIRO }}'
          else
            # default fallback - adjust secret names as you have them
            FIREBASE_CONFIG='${{ secrets.FIREBASE_CONFIG_DEFAULT }}'
            GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY_DEFAULT }}'
            FIREBASE_SA='${{ secrets.FIREBASE_SERVICE_ACCOUNT_DEFAULT }}'
          fi

          # export to GITHUB_ENV so subsequent steps can use them
          echo "VITE_GEMINI_API_KEY=$GEMINI_API_KEY" >> $GITHUB_ENV
          echo "FIREBASE_SERVICE_ACCOUNT_JSON<<EOF" >> $GITHUB_ENV
          echo "$FIREBASE_SA" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          # Parse Firebase config JSON into env vars
          if [ -z "$FIREBASE_CONFIG" ]; then
            echo "Firebase config for client [$CLIENT] is empty" >&2
            exit 1
          fi

          echo "VITE_FIREBASE_API_KEY=$(echo "$FIREBASE_CONFIG" | jq -r '.apiKey')" >> $GITHUB_ENV
          echo "VITE_FIREBASE_AUTH_DOMAIN=$(echo "$FIREBASE_CONFIG" | jq -r '.authDomain')" >> $GITHUB_ENV
          echo "VITE_FIREBASE_PROJECT_ID=$(echo "$FIREBASE_CONFIG" | jq -r '.projectId')" >> $GITHUB_ENV
          echo "VITE_FIREBASE_STORAGE_BUCKET=$(echo "$FIREBASE_CONFIG" | jq -r '.storageBucket')" >> $GITHUB_ENV
          echo "VITE_FIREBASE_MESSAGING_SENDER_ID=$(echo "$FIREBASE_CONFIG" | jq -r '.messagingSenderId')" >> $GITHUB_ENV
          echo "VITE_FIREBASE_APP_ID=$(echo "$FIREBASE_CONFIG" | jq -r '.appId')" >> $GITHUB_ENV

      - name: Install dependencies
        run: npm install

      - name: Build application
        run: npm run build
        env:
          VITE_GEMINI_API_KEY: ${{ env.VITE_GEMINI_API_KEY }}

      - name: Debug environment variables
        run: |
          echo "=== Environment Variables Debug ==="
          echo "VITE_FIREBASE_PROJECT_ID: ${{ env.VITE_FIREBASE_PROJECT_ID }}"
          echo "VITE_FIREBASE_API_KEY: ${{ env.VITE_FIREBASE_API_KEY }}"
          echo "CLIENT: ${{ github.event.inputs.client }}"

      - name: Create dynamic .firebaserc for deployment
        run: |
          PROJECT_ID="${{ env.VITE_FIREBASE_PROJECT_ID }}"
          if [ -z "$PROJECT_ID" ]; then
            echo "ERROR: VITE_FIREBASE_PROJECT_ID is empty!"
            exit 1
          fi

          cat > .firebaserc << EOF
          {
            "projects": {
              "default": "$PROJECT_ID"
            }
          }
          EOF
          echo "Generated .firebaserc with project: $PROJECT_ID"
          cat .firebaserc

      - name: Deploy to Firebase Hosting
        # FirebaseExtended/action-hosting-deploy expects service account json content
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: ${{ env.FIREBASE_SERVICE_ACCOUNT_JSON }}
          channelId: live
          projectId: ${{ env.VITE_FIREBASE_PROJECT_ID }}